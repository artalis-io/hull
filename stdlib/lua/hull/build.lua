--
-- hull.build — Build a standalone hull application binary
--
-- Usage: hull build [options] [app_dir]
--   --runtime lua|js|both  Runtime to include (default: lua)
--   --sign <key_file>      Sign with Ed25519 private key
--   --cc <compiler>        C compiler to use (default: cosmocc)
--   --output <path>        Output binary path (default: app_dir/app)
--
-- SPDX-License-Identifier: AGPL-3.0-or-later
--

local json = require("hull.json")

-- ── Argument parsing ─────────────────────────────────────────────────

local function parse_args()
    local opts = {
        runtime = "lua",
        sign = nil,
        cc = nil,         -- resolved from tool.cc (set by C, default cosmocc)
        output = nil,
        app_dir = ".",
    }

    local i = 1
    while i <= #arg do
        local a = arg[i]
        if a == "--runtime" then
            i = i + 1
            opts.runtime = arg[i]
        elseif a == "--sign" then
            i = i + 1
            opts.sign = arg[i]
        elseif a == "--cc" then
            i = i + 1
            opts.cc = arg[i]
        elseif a == "--output" or a == "-o" then
            i = i + 1
            opts.output = arg[i]
        elseif a:sub(1, 1) ~= "-" then
            opts.app_dir = a
        end
        i = i + 1
    end

    if not opts.output then
        opts.output = opts.app_dir .. "/app"
    end

    return opts
end

-- ── File utilities ───────────────────────────────────────────────────

local function read_file(path)
    return tool.read_file(path)
end

local function write_file(path, data)
    return tool.write_file(path, data)
end

local function file_exists(path)
    return tool.file_exists(path)
end

-- List .lua files recursively in a directory (using tool.find_files)
local function find_lua_files(dir)
    return tool.find_files(dir, "*.lua")
end

-- ── xxd in Lua ───────────────────────────────────────────────────────

local function xxd_data(varname, data)
    local lines = {}
    lines[#lines + 1] = "static const unsigned char " .. varname .. "[] = {"
    for i = 1, #data, 12 do
        local chunk = {}
        for j = i, math.min(i + 11, #data) do
            chunk[#chunk + 1] = string.format("0x%02x", data:byte(j))
        end
        lines[#lines + 1] = "  " .. table.concat(chunk, ", ") .. ","
    end
    lines[#lines + 1] = "};"
    return table.concat(lines, "\n")
end

-- ── Build steps ──────────────────────────────────────────────────────

local function generate_app_registry(app_dir, lua_files)
    local parts = {}
    local entries = {}

    parts[#parts + 1] = "/* Auto-generated by hull build — do not edit */"
    parts[#parts + 1] = ""

    for _, path in ipairs(lua_files) do
        local data = read_file(path)
        if not data then
            tool.stderr("hull build: cannot read " .. path .. "\n")
            tool.exit(1)
        end

        -- Relative path from app_dir
        local rel = path:sub(#app_dir + 2) -- strip "dir/"
        local modname = "./" .. rel:gsub("%.lua$", "")
        local varname = "app_" .. rel:gsub("[/.]", "_")

        parts[#parts + 1] = xxd_data(varname, data)
        parts[#parts + 1] = ""

        entries[#entries + 1] = string.format(
            '    { "%s", %s, sizeof(%s) },', modname, varname, varname)
    end

    parts[#parts + 1] = "typedef struct { const char *name; const unsigned char *data; unsigned int len; } HlStdlibEntry;"
    parts[#parts + 1] = "const HlStdlibEntry hl_app_lua_entries[] = {"
    for _, e in ipairs(entries) do
        parts[#parts + 1] = e
    end
    parts[#parts + 1] = "    { 0, 0, 0 }"
    parts[#parts + 1] = "};"

    return table.concat(parts, "\n")
end

local function sign_app(app_dir, lua_files, key_file, sign_ctx)
    local key_data = read_file(key_file)
    if not key_data then
        tool.stderr("hull build: cannot read key file: " .. key_file .. "\n")
        tool.exit(1)
    end
    local sk_hex = key_data:match("^(%x+)")
    if not sk_hex or #sk_hex ~= 128 then
        tool.stderr("hull build: invalid key file format\n")
        tool.exit(1)
    end

    -- Derive public key
    local pk_file = key_file:gsub("%.key$", ".pub")
    local pk_data = read_file(pk_file)
    local pk_hex = pk_data and pk_data:match("^(%x+)") or ""

    -- Compute file hashes
    local file_hashes = {}
    for _, path in ipairs(lua_files) do
        local data = read_file(path)
        local rel = path:sub(#app_dir + 2)
        file_hashes[rel] = crypto.sha256(data)
    end

    -- Execute app to capture manifest
    local manifest = nil
    local entry = app_dir .. "/app.lua"
    if file_exists(entry) then
        local chunk = tool.loadfile(entry)
        if chunk then
            pcall(chunk)
            manifest = app.get_manifest()
        end
    end

    -- Read platform.sig (required for --sign)
    local platform = nil
    if sign_ctx.platform_sig_path then
        local psig_data = read_file(sign_ctx.platform_sig_path)
        if psig_data then
            platform = json.decode(psig_data)
        end
    end
    if not platform then
        tool.stderr("hull build: cannot read platform.sig (required for --sign)\n")
        tool.stderr("hint: run `hull sign-platform <key>` first\n")
        tool.exit(1)
    end

    -- Capture compiler version
    local cc_version = nil
    if sign_ctx.cc then
        local ver_out = tool.spawn_read({sign_ctx.cc, "--version"})
        if ver_out then
            cc_version = ver_out:match("^([^\n]+)")
        end
    end

    -- Build the signed payload (canonical JSON key order)
    local payload_table = {
        binary_hash = sign_ctx.binary_hash,
        build = {
            cc = sign_ctx.cc or "cosmocc",
            cc_version = cc_version,
            flags = "-std=c11 -O2",
        },
        files = file_hashes,
        manifest = manifest,
        platform = platform,
        trampoline_hash = sign_ctx.trampoline_hash,
    }
    local payload = json.encode(payload_table)
    local sig_hex = crypto.ed25519_sign(payload, sk_hex)

    -- Write package.sig
    local sig_table = {
        binary_hash = sign_ctx.binary_hash,
        build = payload_table.build,
        files = file_hashes,
        manifest = manifest,
        platform = platform,
        trampoline_hash = sign_ctx.trampoline_hash,
        signature = sig_hex,
        public_key = pk_hex,
    }

    local pkg_sig = json.encode(sig_table)
    write_file(app_dir .. "/package.sig", pkg_sig .. "\n")
    print("wrote " .. app_dir .. "/package.sig")
end

local function main()
    local opts = parse_args()

    -- Find Lua files
    local lua_files = find_lua_files(opts.app_dir)
    if #lua_files == 0 then
        tool.stderr("hull build: no .lua files found in " .. opts.app_dir .. "\n")
        tool.exit(1)
    end

    print("hull build: " .. #lua_files .. " Lua file(s) from " .. opts.app_dir)

    -- Create temp directory
    local tmpdir = tool.tmpdir()

    -- Generate app_registry.c
    local registry_c = generate_app_registry(opts.app_dir, lua_files)
    write_file(tmpdir .. "/app_registry.c", registry_c)

    -- Generate app_main.c
    local app_main = [[
extern int hull_main(int argc, char **argv);
int main(int argc, char **argv) { return hull_main(argc, argv); }
]]
    write_file(tmpdir .. "/app_main.c", app_main)

    -- Extract platform library (if embedded)
    local platform_extracted = false
    local platform_lib = tmpdir .. "/libhull_platform.a"

    -- Try to find platform library in known locations
    -- 1. Check if build_assets has it embedded
    local extract_ok = pcall(function()
        local hull_build = require("hull.build_assets")
        hull_build.extract_platform(tmpdir)
    end)
    if extract_ok and file_exists(platform_lib) then
        platform_extracted = true
    end

    -- 2. Check build/ directory (development mode)
    local platform_dir = nil
    if not platform_extracted then
        -- Derive hull binary directory from __hull_exe global
        local hull_dir = ""
        if __hull_exe then
            hull_dir = __hull_exe:match("(.*/)" ) or ""
        end
        local dev_paths = {
            hull_dir,
            "build/",
            "../build/",
        }
        for _, d in ipairs(dev_paths) do
            if file_exists(d .. "libhull_platform.a") then
                tool.copy(d .. "libhull_platform.a", platform_lib)
                platform_dir = d
                platform_extracted = true
                break
            end
        end
    end

    if not platform_extracted then
        tool.stderr("hull build: cannot find libhull_platform.a\n")
        tool.stderr("hint: run `make platform` first, or use an embedded hull build\n")
        tool.rmdir(tmpdir)
        tool.exit(1)
    end

    -- Resolve CC: use tool.cc (set by C from --cc flag, default cosmocc)
    local cc = opts.cc or tool.cc or "cosmocc"
    if platform_dir then
        -- Validate: warn if user --cc doesn't match what platform was built with
        local cc_data = read_file(platform_dir .. "platform_cc")
        if cc_data and opts.cc then
            local platform_cc = cc_data:match("^%s*(.-)%s*$")
            if platform_cc ~= opts.cc then
                tool.stderr("hull build: warning: --cc " .. opts.cc ..
                    " does not match platform (built with " .. platform_cc .. ")\n")
            end
        end
    end

    -- Compile
    print("hull build: compiling...")
    local ok = tool.spawn({cc, "-std=c11", "-O2", "-w", "-c",
                           "-o", tmpdir .. "/app_registry.o",
                           tmpdir .. "/app_registry.c"})
    if not ok then
        tool.stderr("hull build: compilation failed (app_registry.c)\n")
        tool.rmdir(tmpdir)
        tool.exit(1)
    end

    ok = tool.spawn({cc, "-std=c11", "-O2", "-w", "-c",
                     "-o", tmpdir .. "/app_main.o",
                     tmpdir .. "/app_main.c"})
    if not ok then
        tool.stderr("hull build: compilation failed (app_main.c)\n")
        tool.rmdir(tmpdir)
        tool.exit(1)
    end

    -- Link
    print("hull build: linking...")
    ok = tool.spawn({cc, "-o", opts.output,
                     tmpdir .. "/app_main.o",
                     tmpdir .. "/app_registry.o",
                     tmpdir .. "/libhull_platform.a",
                     "-lm", "-lpthread"})
    if not ok then
        tool.stderr("hull build: linking failed\n")
        tool.rmdir(tmpdir)
        tool.exit(1)
    end

    print("hull build: wrote " .. opts.output)

    -- Sign if requested
    if opts.sign then
        -- Find platform.sig alongside the platform library
        local platform_sig_path = nil
        if platform_dir then
            platform_sig_path = platform_dir .. "platform.sig"
        end
        -- Also check tmpdir (extracted embedded builds)
        if not platform_sig_path or not file_exists(platform_sig_path) then
            if file_exists(tmpdir .. "/platform.sig") then
                platform_sig_path = tmpdir .. "/platform.sig"
            end
        end

        local sign_ctx = {
            cc = cc,
            binary_hash = nil,
            trampoline_hash = crypto.sha256(app_main),
            platform_sig_path = platform_sig_path,
        }

        -- Compute binary_hash (SHA256 of the linked output binary)
        local binary_data = read_file(opts.output)
        if binary_data then
            sign_ctx.binary_hash = crypto.sha256(binary_data)
        end

        sign_app(opts.app_dir, lua_files, opts.sign, sign_ctx)
    end

    -- Cleanup
    tool.rmdir(tmpdir)
end

main()
