--
-- hull.build — Build a standalone hull application binary
--
-- Usage: hull build [options] [app_dir]
--   --runtime lua|js|both  Runtime to include (default: lua)
--   --sign <key_file>      Sign with Ed25519 private key
--   --cc <compiler>        C compiler to use (default: cc)
--   --output <path>        Output binary path (default: app_dir/app)
--
-- SPDX-License-Identifier: AGPL-3.0-or-later
--

local json = require("hull.json")

-- ── Argument parsing ─────────────────────────────────────────────────

local function parse_args()
    local opts = {
        runtime = "lua",
        sign = nil,
        cc = nil,         -- resolved after locating platform .a
        output = nil,
        app_dir = ".",
    }

    local i = 1
    while i <= #arg do
        local a = arg[i]
        if a == "--runtime" then
            i = i + 1
            opts.runtime = arg[i]
        elseif a == "--sign" then
            i = i + 1
            opts.sign = arg[i]
        elseif a == "--cc" then
            i = i + 1
            opts.cc = arg[i]
        elseif a == "--output" or a == "-o" then
            i = i + 1
            opts.output = arg[i]
        elseif a:sub(1, 1) ~= "-" then
            opts.app_dir = a
        end
        i = i + 1
    end

    if not opts.output then
        opts.output = opts.app_dir .. "/app"
    end

    return opts
end

-- ── File utilities ───────────────────────────────────────────────────

local function read_file(path)
    return tool.read_file(path)
end

local function write_file(path, data)
    return tool.write_file(path, data)
end

local function file_exists(path)
    return tool.file_exists(path)
end

-- List .lua files recursively in a directory
local function find_lua_files(dir)
    local files = {}
    local output = tool.read('find "' .. dir .. '" -name "*.lua" -type f 2>/dev/null')
    if output then
        for line in output:gmatch("[^\n]+") do
            files[#files + 1] = line
        end
    end
    return files
end

-- ── xxd in Lua ───────────────────────────────────────────────────────

local function xxd_data(varname, data)
    local lines = {}
    lines[#lines + 1] = "static const unsigned char " .. varname .. "[] = {"
    for i = 1, #data, 12 do
        local chunk = {}
        for j = i, math.min(i + 11, #data) do
            chunk[#chunk + 1] = string.format("0x%02x", data:byte(j))
        end
        lines[#lines + 1] = "  " .. table.concat(chunk, ", ") .. ","
    end
    lines[#lines + 1] = "};"
    return table.concat(lines, "\n")
end

-- ── Build steps ──────────────────────────────────────────────────────

local function generate_app_registry(app_dir, lua_files)
    local parts = {}
    local entries = {}

    parts[#parts + 1] = "/* Auto-generated by hull build — do not edit */"
    parts[#parts + 1] = ""

    for _, path in ipairs(lua_files) do
        local data = read_file(path)
        if not data then
            tool.stderr("hull build: cannot read " .. path .. "\n")
            tool.exit(1)
        end

        -- Relative path from app_dir
        local rel = path:sub(#app_dir + 2) -- strip "dir/"
        local modname = "./" .. rel:gsub("%.lua$", "")
        local varname = "app_" .. rel:gsub("[/.]", "_")

        parts[#parts + 1] = xxd_data(varname, data)
        parts[#parts + 1] = ""

        entries[#entries + 1] = string.format(
            '    { "%s", %s, sizeof(%s) },', modname, varname, varname)
    end

    parts[#parts + 1] = "typedef struct { const char *name; const unsigned char *data; unsigned int len; } HlStdlibEntry;"
    parts[#parts + 1] = "const HlStdlibEntry hl_app_lua_entries[] = {"
    for _, e in ipairs(entries) do
        parts[#parts + 1] = e
    end
    parts[#parts + 1] = "    { 0, 0, 0 }"
    parts[#parts + 1] = "};"

    return table.concat(parts, "\n")
end

local function sign_app(app_dir, lua_files, key_file)
    local key_data = read_file(key_file)
    if not key_data then
        tool.stderr("hull build: cannot read key file: " .. key_file .. "\n")
        tool.exit(1)
    end
    local sk_hex = key_data:match("^(%x+)")
    if not sk_hex or #sk_hex ~= 128 then
        tool.stderr("hull build: invalid key file format\n")
        tool.exit(1)
    end

    -- Compute file hashes
    local file_hashes = {}
    for _, path in ipairs(lua_files) do
        local data = read_file(path)
        local rel = path:sub(#app_dir + 2)
        file_hashes[rel] = crypto.sha256(data)
    end

    -- Execute app to capture manifest
    local manifest = nil
    local entry = app_dir .. "/app.lua"
    if file_exists(entry) then
        local chunk = tool.loadfile(entry)
        if chunk then
            pcall(chunk)
            manifest = app.get_manifest()
        end
    end

    -- Build payload and sign
    local payload = json.encode({
        files = file_hashes,
        manifest = manifest,
    })
    local sig_hex = crypto.ed25519_sign(payload, sk_hex)

    -- Derive public key filename
    local pk_file = key_file:gsub("%.key$", ".pub")
    local pk_data = read_file(pk_file)
    local pk_hex = pk_data and pk_data:match("^(%x+)") or ""

    -- Write hull.sig
    local hull_sig = json.encode({
        version = 1,
        files = file_hashes,
        manifest = manifest,
        signature = sig_hex,
        public_key = pk_hex,
    })
    write_file(app_dir .. "/hull.sig", hull_sig .. "\n")
    print("wrote " .. app_dir .. "/hull.sig")
end

local function main()
    local opts = parse_args()

    -- Find Lua files
    local lua_files = find_lua_files(opts.app_dir)
    if #lua_files == 0 then
        tool.stderr("hull build: no .lua files found in " .. opts.app_dir .. "\n")
        tool.exit(1)
    end

    print("hull build: " .. #lua_files .. " Lua file(s) from " .. opts.app_dir)

    -- Create temp directory
    local tmpdir = tool.tmpdir()

    -- Generate app_registry.c
    local registry_c = generate_app_registry(opts.app_dir, lua_files)
    write_file(tmpdir .. "/app_registry.c", registry_c)

    -- Generate app_main.c
    local app_main = [[
extern int hull_main(int argc, char **argv);
int main(int argc, char **argv) { return hull_main(argc, argv); }
]]
    write_file(tmpdir .. "/app_main.c", app_main)

    -- Extract platform library (if embedded)
    local platform_extracted = false
    local platform_lib = tmpdir .. "/libhull_platform.a"

    -- Try to find platform library in known locations
    -- 1. Check if build_assets has it embedded
    local extract_ok = pcall(function()
        local hull_build = require("hull.build_assets")
        hull_build.extract_platform(tmpdir)
    end)
    if extract_ok and file_exists(platform_lib) then
        platform_extracted = true
    end

    -- 2. Check build/ directory (development mode)
    local platform_dir = nil
    if not platform_extracted then
        -- Derive hull binary directory from __hull_exe global
        local hull_dir = ""
        if __hull_exe then
            hull_dir = __hull_exe:match("(.*/)" ) or ""
        end
        local dev_paths = {
            hull_dir,
            "build/",
            "../build/",
        }
        for _, d in ipairs(dev_paths) do
            if file_exists(d .. "libhull_platform.a") then
                tool.exec('cp "' .. d .. 'libhull_platform.a" "' .. platform_lib .. '"')
                platform_dir = d
                platform_extracted = true
                break
            end
        end
    end

    if not platform_extracted then
        tool.stderr("hull build: cannot find libhull_platform.a\n")
        tool.stderr("hint: run `make platform` first, or use an embedded hull build\n")
        tool.exec('rm -rf "' .. tmpdir .. '"')
        tool.exit(1)
    end

    -- Resolve CC: use platform_cc from build dir, or fall back to "cc"
    local cc = opts.cc
    if not cc and platform_dir then
        local cc_data = read_file(platform_dir .. "platform_cc")
        if cc_data then
            cc = cc_data:match("^%s*(.-)%s*$")  -- trim whitespace
        end
    end
    if not cc then
        cc = "cc"
    end
    if platform_dir then
        -- Validate: warn if user --cc doesn't match what platform was built with
        local cc_data = read_file(platform_dir .. "platform_cc")
        if cc_data and opts.cc then
            local platform_cc = cc_data:match("^%s*(.-)%s*$")
            if platform_cc ~= opts.cc then
                tool.stderr("hull build: warning: --cc " .. opts.cc ..
                    " does not match platform (built with " .. platform_cc .. ")\n")
            end
        end
    end
    local compile_cmd = string.format(
        '%s -std=c11 -O2 -w -c -o "%s/app_registry.o" "%s/app_registry.c" && ' ..
        '%s -std=c11 -O2 -w -c -o "%s/app_main.o" "%s/app_main.c"',
        cc, tmpdir, tmpdir,
        cc, tmpdir, tmpdir)

    print("hull build: compiling...")
    local ok = tool.exec(compile_cmd)
    if not ok then
        tool.stderr("hull build: compilation failed\n")
        tool.exec('rm -rf "' .. tmpdir .. '"')
        tool.exit(1)
    end

    -- Link
    local link_cmd = string.format(
        '%s -o "%s" "%s/app_main.o" "%s/app_registry.o" "%s/libhull_platform.a" -lm -lpthread',
        cc, opts.output, tmpdir, tmpdir, tmpdir)

    print("hull build: linking...")
    ok = tool.exec(link_cmd)
    if not ok then
        tool.stderr("hull build: linking failed\n")
        tool.exec('rm -rf "' .. tmpdir .. '"')
        tool.exit(1)
    end

    print("hull build: wrote " .. opts.output)

    -- Sign if requested
    if opts.sign then
        sign_app(opts.app_dir, lua_files, opts.sign)
    end

    -- Cleanup
    tool.exec('rm -rf "' .. tmpdir .. '"')
end

main()
