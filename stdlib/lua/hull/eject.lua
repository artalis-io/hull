--
-- hull.eject — Export standalone Makefile project
--
-- Usage: hull eject [app_dir] [-o output_dir]
--
-- Generates a self-contained project that builds without hull.
--
-- SPDX-License-Identifier: AGPL-3.0-or-later
--

-- ── Argument parsing ─────────────────────────────────────────────────

local function parse_args()
    local opts = {
        app_dir = ".",
        output = nil,
    }

    local i = 1
    while i <= #arg do
        local a = arg[i]
        if a == "-o" or a == "--output" then
            i = i + 1
            opts.output = arg[i]
        elseif a:sub(1, 1) ~= "-" then
            opts.app_dir = a
        end
        i = i + 1
    end

    if not opts.output then
        opts.output = opts.app_dir .. "_ejected"
    end

    return opts
end

-- ── Templates ────────────────────────────────────────────────────────

local function gen_makefile()
    return [[CC      ?= cosmocc
CFLAGS  := -std=c11 -O2 -w
OUTPUT  ?= app

APP_FILES := $(shell find app -name '*.lua' -o -name '*.js')

.PHONY: all clean

all: $(OUTPUT)

build:
	mkdir -p build

build/app_registry.c: $(APP_FILES) | build
	sh scripts/gen_registry.sh app > $@

build/app_registry.o: build/app_registry.c | build
	$(CC) $(CFLAGS) -Isrc -c -o $@ $<

build/app_main.o: src/app_main.c | build
	$(CC) $(CFLAGS) -c -o $@ $<

$(OUTPUT): build/app_main.o build/app_registry.o platform/libhull_platform.a
	$(CC) -o $@ $^ -lm -lpthread

clean:
	rm -rf build $(OUTPUT)
]]
end

local function gen_app_main()
    return [[/* app_main.c — Thin entry point (calls hull_main from platform lib) */
#include "entry.h"
extern int hull_main(int argc, char **argv);
int main(int argc, char **argv) { return hull_main(argc, argv); }
]]
end

local function gen_entry_h()
    return [[/* entry.h — App entry type definition */
#ifndef HL_ENTRY_H
#define HL_ENTRY_H

typedef struct {
    const char *name;
    const unsigned char *data;
    unsigned int len;
} HlStdlibEntry;

#endif /* HL_ENTRY_H */
]]
end

local function gen_registry_sh()
    return [[#!/bin/sh
# gen_registry.sh — Generate app_registry.c from app files
#
# Usage: sh scripts/gen_registry.sh <app_dir>
#
# Generates a C file with embedded app files as byte arrays,
# plus a registry table mapping module names to data.

APP_DIR="${1:-.}"

echo "/* Auto-generated by gen_registry.sh — do not edit */"
echo '#include "entry.h"'
echo ""

# Find all .lua files, sorted for deterministic output
FILES=$(find "$APP_DIR" -name '*.lua' -not -path '*/.*' | sort)

# Emit byte arrays
for f in $FILES; do
    # Variable name: replace /. with _
    varname=$(echo "$f" | sed 's/[\/.]/_/g')
    echo "static const unsigned char ${varname}[] = {"

    # Use xxd if available, otherwise fall back to od
    if command -v xxd >/dev/null 2>&1; then
        xxd -i < "$f" | grep -v '^unsigned'
    else
        od -An -tx1 -v "$f" | sed 's/ \([0-9a-f][0-9a-f]\)/0x\1,/g; s/^/  /'
    fi

    echo "};"
    echo ""
done

# Emit registry table
echo "typedef struct { const char *name; const unsigned char *data; unsigned int len; } HlStdlibEntry;"
echo "const HlStdlibEntry hl_app_lua_entries[] = {"

for f in $FILES; do
    varname=$(echo "$f" | sed 's/[\/.]/_/g')
    # Module name: strip app_dir prefix and .lua suffix, add ./ prefix
    modname=$(echo "$f" | sed "s|^${APP_DIR}/||; s|\.lua$||")
    echo "    { \"./${modname}\", ${varname}, sizeof(${varname}) },"
done

echo "    { 0, 0, 0 }"
echo "};"
]]
end

-- ── File utilities ───────────────────────────────────────────────────

local function write_file(path, data)
    return tool.write_file(path, data)
end

-- ── Main ─────────────────────────────────────────────────────────────

local function main()
    local opts = parse_args()

    -- Verify app_dir has files
    local files = tool.find_files(opts.app_dir, "*.lua")
    if #files == 0 then
        tool.stderr("hull eject: no .lua files found in " .. opts.app_dir .. "\n")
        tool.exit(1)
    end

    -- Check output doesn't already exist
    if tool.file_exists(opts.output) then
        tool.stderr("hull eject: output directory '" .. opts.output .. "' already exists\n")
        tool.exit(1)
    end

    -- Find platform library
    local platform_lib = nil
    local hull_dir = ""
    if __hull_exe then
        hull_dir = __hull_exe:match("(.*/)" ) or ""
    end
    local search_paths = {
        hull_dir,
        "build/",
        "../build/",
    }
    for _, d in ipairs(search_paths) do
        if tool.file_exists(d .. "libhull_platform.a") then
            platform_lib = d .. "libhull_platform.a"
            break
        end
    end

    if not platform_lib then
        tool.stderr("hull eject: cannot find libhull_platform.a\n")
        tool.stderr("hint: run `make platform` first\n")
        tool.exit(1)
    end

    -- Create output structure
    local dir = opts.output
    tool.mkdir(dir)
    tool.mkdir(dir .. "/src")
    tool.mkdir(dir .. "/app")
    tool.mkdir(dir .. "/platform")
    tool.mkdir(dir .. "/scripts")
    tool.mkdir(dir .. "/build")

    -- Write generated files
    write_file(dir .. "/Makefile", gen_makefile())
    write_file(dir .. "/src/app_main.c", gen_app_main())
    write_file(dir .. "/src/entry.h", gen_entry_h())
    write_file(dir .. "/scripts/gen_registry.sh", gen_registry_sh())

    -- Copy platform library
    tool.copy(platform_lib, dir .. "/platform/libhull_platform.a")

    -- Copy app files, preserving directory structure
    for _, path in ipairs(files) do
        local rel = path:sub(#opts.app_dir + 2)
        local dest = dir .. "/app/" .. rel

        -- Create parent directories
        local parent = dest:match("(.*/)")
        if parent then
            tool.mkdir(parent)
        end

        tool.copy(path, dest)
    end

    print("hull eject: created " .. dir .. "/")
    print("  " .. dir .. "/Makefile")
    print("  " .. dir .. "/src/app_main.c")
    print("  " .. dir .. "/src/entry.h")
    print("  " .. dir .. "/scripts/gen_registry.sh")
    print("  " .. dir .. "/platform/libhull_platform.a")
    for _, path in ipairs(files) do
        local rel = path:sub(#opts.app_dir + 2)
        print("  " .. dir .. "/app/" .. rel)
    end
    print("")
    print("Next steps:")
    print("  cd " .. dir)
    print("  make")
    print("  ./app")
end

main()
